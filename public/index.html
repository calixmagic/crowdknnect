<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Exp√©rience Magique</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.5s ease;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        /* Hidden by default */
        #mask-overlay,
        #eye-container,
        #unlock-icon,
        #wave-overlay,
        #fire-container,
        #static-overlay,
        #puzzle-container {
            display: none;
        }

        .screen.active {
            display: flex;
        }

        #connect-screen {
            z-index: 1000;
            background: #000;
        }

        .mystic-wheel {
            width: 80px;
            height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 2s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
            }

            70% {
                transform: scale(1.05);
                box-shadow: 0 0 0 12px rgba(255, 255, 255, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
            }
        }

        #start-btn {
            animation: pulse 2s infinite;
        }

        /* New Connect Screen Styles */
        #connect-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            width: 100%;
        }

        #connect-logo {
            width: 150px;
            height: 150px;
            object-fit: contain;
            border-radius: 0;
            /* Free shape */
            /* Animation removed to fix "bug" of moving alone */
            /* animation: pulse-zoom 2s infinite ease-in-out; */
            margin-bottom: 20px;
            /* Default fallback if no logo */
            background: transparent;
            transition: width 0.3s ease-out, height 0.3s ease-out;
            /* Smooth zoom */
            max-width: 80vw;
            max-height: 50vh;
        }

        #welcome-text {
            font-size: 1.2rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #sub-text {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            font-weight: 300;
        }

        /* Removed pulse-zoom animation as requested to allow manual zoom control without conflict */
        /*
        @keyframes pulse-zoom {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.5)); }
            100% { transform: scale(1); opacity: 0.8; }
        }
        */

        #logo-container {
            width: 80vw;
            max-width: 400px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #logo-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
            transition: transform 0.2s ease-out;
        }

        #engine-screen {
            z-index: 500;
        }

        #emoji-display {
            font-size: 15vh;
        }

        #media-display {
            width: 85%;
            max-width: 500px;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: none;
        }

        #video-display {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
        }

        #final-screen {
            z-index: 2000;
            background: #fff;
            color: #000;
            padding: 20px;
            text-align: center;
        }

        .final-btn {
            width: 100%;
            max-width: 300px;
            padding: 20px;
            margin: 10px 0;
            border: none;
            border-radius: 15px;
            font-weight: 700;
            font-size: 16px;
            cursor: pointer;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-insta {
            background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888);
            color: #fff;
        }

        .btn-google {
            background: #4285F4;
            color: #fff;
        }

        /* Flash Effects */
        body.flash-bg {
            background-color: #fff !important;
        }

        body.flash-strobe {
            animation: strobeEffect 0.1s infinite;
        }

        @keyframes strobeEffect {

            0%,
            50% {
                background-color: #000;
            }

            51%,
            100% {
                background-color: #fff;
            }
        }

        .red {
            color: #f00 !important;
        }

        .black {
            color: #fff !important;
        }

        .white-bg {
            background-color: #fff !important;
            color: #000 !important;
        }

        .flash-bg {
            background-color: #fff !important;
            transition: none !important;
        }

        .blackout-bg {
            background-color: #000 !important;
            transition: none !important;
        }

        /* Heart morphing animation */
        #heart-svg {
            position: absolute;
            width: 100px;
            height: 100px;
            display: none;
        }

        #heart-svg.active {
            display: block;
            animation: heartMorph 3s ease-in-out forwards;
        }

        @keyframes heartMorph {
            0% {
                transform: scale(0.1);
                opacity: 1;
            }

            50% {
                transform: scale(1.5);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Countdown */
        #countdown-display {
            position: absolute;
            font-size: 30vh;
            font-weight: bold;
            color: #fff;
            display: none;
            animation: countdownPulse 1s infinite;
        }

        @keyframes countdownPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }
        }

        /* Dice 3D */
        #dice-container {
            position: absolute;
            width: 200px;
            height: 200px;
            perspective: 800px;
            display: none;
        }

        #dice {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            animation: diceRoll 2s ease-out forwards;
        }

        .dice-face {
            position: absolute;
            width: 200px;
            height: 200px;
            background: #000;
            border: 3px solid #333;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 80px;
            font-weight: bold;
        }

        .dice-face:nth-child(1) {
            transform: rotateY(0deg) translateZ(100px);
        }

        .dice-face:nth-child(2) {
            transform: rotateY(180deg) translateZ(100px);
        }

        .dice-face:nth-child(3) {
            transform: rotateY(90deg) translateZ(100px);
        }

        .dice-face:nth-child(4) {
            transform: rotateY(-90deg) translateZ(100px);
        }

        .dice-face:nth-child(5) {
            transform: rotateX(90deg) translateZ(100px);
        }

        .dice-face:nth-child(6) {
            transform: rotateX(-90deg) translateZ(100px);
        }

        @keyframes diceRoll {
            0% {
                transform: rotate3d(1, 1, 1, 0deg);
            }

            100% {
                transform: rotate3d(1, 1, 1, 720deg);
            }
        }

        /* Ripple from logo */
        #ripple-overlay {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            display: none;
            pointer-events: none;
        }

        #ripple-overlay.active {
            animation: rippleExpand 2s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(30);
                opacity: 0;
            }
        }

        /* Audio (hidden) */
        #audio-player {
            display: none;
        }

        /* Phase 2 Steps */
        /* Text */
        #text-display {
            position: absolute;
            font-size: 12vh;
            font-weight: bold;
            color: #fff;
            text-align: center;
            max-width: 90%;
            display: none;
        }

        /* Pulse */
        body.pulse-bg {
            animation: pulseEffect 1.5s ease-in-out infinite !important;
        }

        @keyframes pulseEffect {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Spiral */
        #spiral-overlay {
            position: absolute;
            width: 300px;
            height: 300px;
            border: 5px solid #fff;
            border-radius: 50%;
            display: none;
        }

        #spiral-overlay.active {
            animation: spiralSpin 3s linear infinite;
        }

        @keyframes spiralSpin {
            0% {
                transform: rotate(0deg) scale(0.5);
            }

            50% {
                transform: rotate(180deg) scale(1.5);
            }

            100% {
                transform: rotate(360deg) scale(0.5);
            }
        }

        /* Color overlay */
        #color-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            transition: background-color 0.5s;
        }

        /* Number */
        #number-display {
            position: absolute;
            font-size: 25vh;
            font-weight: bold;
            color: #fff;
            display: none;
        }

        /* Breathing */
        body.breathing-bg {
            animation: breatheEffect 4s ease-in-out infinite;
            /* Default, overridden by JS */
        }

        @keyframes breatheEffect {

            0%,
            100% {
                background-color: #000;
                transform: scale(1);
            }

            50% {
                background-color: var(--breathing-color, #333);
                transform: scale(1.02);
            }
        }

        /* Glitch */
        #glitch-text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10vh;
            font-weight: bold;
            color: #fff;
            display: none;
            text-shadow: 2px 2px #f00, -2px -2px #00f;
            z-index: 1000;
        }

        /* Glitch */
        body.glitch-bg {
            animation: glitchEffect 0.3s infinite !important;
        }

        @keyframes glitchEffect {
            0% {
                transform: translate(0);
                filter: hue-rotate(0deg);
            }

            20% {
                transform: translate(-2px, 2px);
                filter: hue-rotate(90deg);
            }

            40% {
                transform: translate(2px, -2px);
                filter: hue-rotate(180deg);
            }

            60% {
                transform: translate(-2px, -2px);
                filter: hue-rotate(270deg);
            }

            80% {
                transform: translate(2px, 2px);
                filter: hue-rotate(360deg);
            }

            100% {
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
        }

        /* Ripple center */
        #ripple-center {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 50px;
            height: 50px;
            margin-left: -25px;
            margin-top: -25px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            display: none;
        }

        #ripple-center.active {
            animation: rippleCenterExpand 2s ease-out forwards;
        }

        @keyframes rippleCenterExpand {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            100% {
                transform: scale(30);
                opacity: 0;
            }
        }

        /* Zoom */
        body.zoom-bg {
            animation: zoomEffect 3s ease-in-out forwards !important;
        }

        @keyframes zoomEffect {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(3);
            }
        }

        /* Shake */
        body.shake-bg {
            animation: shakeEffect 0.5s infinite !important;
        }

        @keyframes shakeEffect {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        /* Fade */
        #fade-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            transition: opacity 2s;
        }

        #fade-overlay.active {
            opacity: 1;
        }

        /* Phase 3 Advanced Steps */
        /* CardFlip */
        #card-flip-container {
            position: absolute;
            width: 300px;
            height: 450px;
            perspective: 1000px;
            display: none;
        }

        #card-flip {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: cardFlipAnim 2s ease-in-out forwards;
        }

        @keyframes cardFlipAnim {
            0% {
                transform: rotateY(0deg);
            }

            100% {
                transform: rotateY(180deg);
            }
        }

        /* Slot */
        #slot-container {
            position: absolute;
            display: none;
            font-size: 15vh;
        }

        /* Pinpoint */
        #pinpoint-target {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 5px solid #f00;
            border-radius: 50%;
            display: none;
            animation: pinpointShrink 3s ease-in forwards;
        }

        @keyframes pinpointShrink {
            0% {
                transform: scale(5);
                opacity: 0.5;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Unlock */
        #unlock-icon {
            position: absolute;
            font-size: 20vh;
            display: none;
            animation: unlockAnim 2s ease-out forwards;
        }

        @keyframes unlockAnim {
            0% {
                content: 'üîí';
            }

            50% {
                content: 'üîì';
                transform: rotate(0deg);
            }

            100% {
                content: 'üîì';
                transform: rotate(20deg);
            }
        }

        /* Mirror */
        body.mirror-h {
            transform: scaleX(-1);
        }

        body.mirror-v {
            transform: scaleY(-1);
        }

        /* Wave */
        #wave-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(transparent, rgba(0, 150, 255, 0.5));
            display: none;
            animation: waveMove 3s ease-in-out infinite;
        }

        @keyframes waveMove {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-30px);
            }
        }

        /* Sparkle */
        .sparkle-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            animation: sparklefall 2s linear forwards;
        }

        @keyframes sparklefall {
            0% {
                opacity: 1;
                transform: translateY(0);
            }

            100% {
                opacity: 0;
                transform: translateY(100vh);
            }
        }

        /* Fire */
        #fire-container {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 40%;
            display: none;
            background: linear-gradient(to top, #ff4500, #ff8c00, transparent);
            animation: fireFlicker 0.3s infinite alternate;
        }

        @keyframes fireFlicker {
            0% {
                opacity: 0.8;
                transform: scaleY(1);
            }

            100% {
                opacity: 1;
                transform: scaleY(1.1);
            }
        }

        /* Beat */
        body.beat-flash {
            animation: beatFlash 0.3s ease-in-out !important;
        }

        @keyframes beatFlash {

            0%,
            100% {
                background-color: inherit;
            }

            50% {
                background-color: #fff;
            }
        }

        /* StaticNoise */
        #static-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, #000 0px, #fff 2px, #000 4px);
            display: none;
            animation: staticFlicker 0.1s infinite;
        }

        @keyframes staticFlicker {
            0% {
                opacity: 0.8;
            }

            100% {
                opacity: 1;
            }
        }

        /* Eye */
        #eye-container {
            position: absolute;
            font-size: 20vh;
            display: none;
            animation: eyeBlink 3s ease-in-out infinite;
        }

        @keyframes eyeBlink {

            0%,
            90%,
            100% {
                content: 'üëÅÔ∏è';
            }

            93%,
            97% {
                content: 'üòë';
            }
        }

        /* Puzzle */
        #puzzle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
        }

        .puzzle-piece {
            position: absolute;
            width: 50%;
            height: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
        }

        /* Mask */
        #mask-overlay {
            position: absolute;
            font-size: 30vh;
            display: none;
            animation: maskAppear 2s ease-out forwards;
        }

        @keyframes maskAppear {
            0% {
                opacity: 0;
                transform: scale(0);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Crystal */
        #crystal-ball {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(100, 100, 255, 0.4));
            display: none;
            animation: crystalGlow 2s ease-in-out infinite;
        }

        @keyframes crystalGlow {

            0%,
            100% {
                box-shadow: 0 0 20px #fff, 0 0 40px #88f;
            }

            50% {
                box-shadow: 0 0 40px #fff, 0 0 80px #88f;
            }
        }

        /* Snapshot */
        #snapshot-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: #fff;
            display: none;
        }

        #snapshot-flash.active {
            animation: cameraFlash 0.5s ease-out forwards;
        }

        @keyframes cameraFlash {
            0% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        /* Starfield */
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fff;
            border-radius: 50%;
            animation: starMove 3s linear infinite;
        }

        @keyframes starMove {
            0% {
                transform: translateZ(0) scale(1);
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                transform: translateZ(100px) scale(3);
                opacity: 0;
            }
        }

        #arrow {
            animation: arrowBounce 2s infinite;
        }

        @keyframes arrowBounce {

            0%,
            20%,
            50%,
            80%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            40% {
                transform: translateX(-50%) translateY(-20px);
            }

            60% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* Admin Panel CSS */
        #settings-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            z-index: 2000;
            display: none;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            text-align: left;
        }

        #settings-panel.open {
            display: flex;
        }

        .section-title {
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 20px 0 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .add-link {
            color: #007aff;
            text-transform: none;
            letter-spacing: 0;
            font-size: 12px;
            cursor: pointer;
        }

        .row {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
        }

        input,
        select {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 12px;
            border-radius: 10px;
            font-size: 14px;
            width: 100%;
        }

        #steps-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .step-item {
            background: #151515;
            border: 1px solid #222;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: grab;
            transition: background 0.2s;
        }

        .step-add-form {
            background: #0d1117;
            border: 1px dashed #007aff;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .step-add-form select,
        .step-add-form input {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            flex: 1;
            min-width: 80px;
        }

        .step-add-form button {
            background: #34c759;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .step-delete {
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 5px;
        }

        .step-item.dragging {
            opacity: 0.5;
            background: #222;
        }

        .step-handle {
            color: #444;
            font-size: 20px;
            cursor: grab;
        }

        .step-info {
            flex: 1;
        }

        .step-name {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .step-meta {
            font-size: 11px;
            color: #666;
        }

        .step-toggle {
            width: 40px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
        }

        .step-toggle.active {
            background: #34c759;
        }

        .step-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            transition: 0.2s;
        }

        .step-toggle.active::after {
            left: 22px;
        }

        .btn {
            background: #007aff;
            color: #fff;
            border: none;
            padding: 15px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            width: 100%;
        }

        .btn-secondary {
            background: #222;
            border: 1px solid #333;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
        }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #007aff;
            cursor: pointer;
            margin-top: -7px;
        }

        #debug-log {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 90%;
            height: 60px;
            pointer-events: auto;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            z-index: 3000;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: monospace;
            text-align: left;
            line-height: 1.3;
        }

        /* Toggle switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #666;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #34c759;
        }

        input:checked+.slider:before {
            background-color: white;
            transform: translateX(20px);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>

<body id="main-body">



    <canvas id="bg-canvas"
        style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;pointer-events:none;"></canvas>
    <div id="bg-overlay-css" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;pointer-events:none;">
    </div>


    <!-- √âcran 1 : Participer -->
    <div id="connect-screen" class="screen active">
        <!-- <div class="mystic-wheel"></div> Removed wheel in favor of logo -->
        <div id="connect-wrapper">
            <img id="connect-logo" src="" alt="Logo" style="display:none;">
            <div id="welcome-text">TOUCHER POUR COMMENCER</div>
            <div id="sub-text">Exp√©rience Interactive</div>
        </div>
    </div>

    <!-- √âcran 2 : Logo / Attente -->
    <div id="logo-screen" class="screen">
        <div id="logo-container"><img id="logo-img" src="" alt="Logo"></div>
        <p id="tagline-text"
            style="color:#fff; font-size:0.8rem; letter-spacing:2px; text-transform:uppercase; text-align:center; padding:0 20px;">
            R√©aliser une exp√©rience.
        </p>
    </div>

    <!-- √âcran 3 : Moteur -->
    <div id="engine-screen" class="screen">
        <div id="emoji-display"></div>
        <img id="media-display" src="" alt="Media">
        <video id="video-display" playsinline></video>
        <img id="arrow" src="fleche.png" alt=""
            style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);display:none;width:50vw;max-width:350px;pointer-events:none;">
        <svg id="heart-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <path id="heart-path" fill="#ff0000" d="M50,30 C50,30 50,30 50,30 C50,30 50,30 50,30 Z">
                <animate attributeName="d" dur="2s" fill="freeze" from="M50,50 L50,50 L50,50 Z"
                    to="M50,85 C25,70 15,55 15,40 C15,25 25,15 40,15 C45,15 50,20 50,20 C50,20 55,15 60,15 C75,15 85,25 85,40 C85,55 75,70 50,85 Z" />
            </path>
        </svg>
        <div id="countdown-display"></div>
        <div id="dice-container">
            <div id="dice">
                <div class="dice-face">1</div>
                <div class="dice-face">2</div>
                <div class="dice-face">3</div>
                <div class="dice-face">4</div>
                <div class="dice-face">5</div>
                <div class="dice-face">6</div>
            </div>
        </div>
        <div id="ripple-overlay"></div>
        <audio id="audio-player"></audio>
        <div id="text-display"></div>
        <div id="lottie-display"
            style="position:absolute;top:0;left:0;width:100%;height:100%;display:none;pointer-events:none;z-index:90;">
        </div>
        <div id="spiral-overlay"></div>
        <div id="color-overlay"></div>
        <div id="number-display"></div>
        <div id="ripple-center"></div>
        <div id="fade-overlay"></div>
        <div id="card-flip-container">
            <div id="card-flip"></div>
        </div>
        <div id="slot-container"></div>
        <div id="pinpoint-target"></div>
        <div id="unlock-icon">üîí</div>
        <div id="wave-overlay"></div>
        <div id="eye-container">üëÅÔ∏è</div>
        <div id="mask-overlay">üé≠</div>
        <div id="crystal-ball"></div>
        <div id="snapshot-flash"></div>
        <div id="glitch-text-overlay"></div>
    </div>

    <!-- √âcran 4 : Final -->
    <div id="final-screen" class="screen">
        <h2 style="margin-bottom:20px;">MERCI !</h2>
        <a href="https://www.instagram.com/calix_magicien/" target="_blank" class="final-btn btn-insta">S'ABONNER SUR
            INSTAGRAM</a>
        <a id="redirection-btn" href="#" target="_blank" class="final-btn btn-google">PARTAGER MON AVIS</a>
        <p style="margin-top:20px; font-size:12px; color:#888;" onclick="window.location.reload()">Rejouer</p>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <!-- Admin Settings Panel -->
    <div id="settings-panel">
        <div style="display:flex; justify-content:space-between; align-items:baseline; margin-bottom:20px;">
            <h2>Magic Lab</h2>
            <div id="connection-count"
                style="font-size:12px; background:#222; padding:4px 10px; border-radius:20px; color:#34c759;">üë§ 1</div>
        </div>

        <div class="header">
            <h1>CrowdConnect Admin</h1>
            <div class="row"><label>Routine Active <span class="add-link" onclick="addRoutine()">+
                        Nouvelle</span></label>
                <select id="routine-select" onchange="switchRoutine(this.value)"></select>
            </div>

            <div class="section-title">√âtapes de la s√©quence <span class="add-link" onclick="showAddStepForm()">+
                    Ajouter</span><span class="guide-toggle" onclick="toggleGuide()">‚ùì Guide</span></div>
            <div id="step-guide">
                <div class="guide-content">
                    <button class="guide-close" onclick="toggleGuide()">√ó</button>
                    <h3>üìã Guide des types d'√©tapes</h3>
                    <table>
                        <tr>
                            <td>‚¨á Arrow</td>
                            <td>Fl√®che rouge en bas d'√©cran</td>
                        </tr>
                        <tr>
                            <td>üîä Audio</td>
                            <td>Audio avec fade volume (startVol‚ÜíendVol)</td>
                        </tr>
                        <tr>
                            <td>üéµ Beat</td>
                            <td>Flash au rythme d'un BPM</td>
                        </tr>
                        <tr>
                            <td>‚¨õ Blackout</td>
                            <td>√âcran noir total</td>
                        </tr>
                        <tr>
                            <td>ü´Å Breathing</td>
                            <td>Animation respiration Zen</td>
                        </tr>
                        <tr>
                            <td>üé¥ CardFlip</td>
                            <td>Carte 3D qui se retourne</td>
                        </tr>
                        <tr>
                            <td>üé® Color</td>
                            <td>Couleur de fond personnalis√©e</td>
                        </tr>
                        <tr>
                            <td>üî¢ Countdown</td>
                            <td>Compte √† rebours (startFrom: 3-10)</td>
                        </tr>
                        <tr>
                            <td>üîÆ Crystal</td>
                            <td>Boule de cristal luminescente</td>
                        </tr>
                        <tr>
                            <td>üé≤ Dice</td>
                            <td>D√© 3D ‚Üí face finale (finalFace: 1-6)</td>
                        </tr>
                        <tr>
                            <td>üÉè Emojis</td>
                            <td>Symboles de cartes acc√©l√©r√©s (‚ô†‚ô•‚ô£‚ô¶)</td>
                        </tr>
                        <tr>
                            <td>üëÅÔ∏è Eye</td>
                            <td>≈íil qui cligne</td>
                        </tr>
                        <tr>
                            <td>üå´Ô∏è Fade</td>
                            <td>Fondu vers noir ou blanc</td>
                        </tr>
                        <tr>
                            <td>üî• Fire</td>
                            <td>Flammes montantes</td>
                        </tr>
                        <tr>
                            <td>‚ö° Flash</td>
                            <td>Flash blanc + vibration (500ms)</td>
                        </tr>
                        <tr>
                            <td>‚ö° Glitch</td>
                            <td>Effet matrix/bug visuel</td>
                        </tr>
                        <tr>
                            <td>‚ù§Ô∏è Heart</td>
                            <td>Animation morphing point ‚Üí c≈ìur battant</td>
                        </tr>
                        <tr>
                            <td>üéÜ Lottie</td>
                            <td>Animation Lottie JSON</td>
                        </tr>
                        <tr>
                            <td>üé≠ Mask</td>
                            <td>Masque qui appara√Æt</td>
                        </tr>
                        <tr>
                            <td>ü™û Mirror</td>
                            <td>Effet miroir horizontal/vertical</td>
                        </tr>
                        <tr>
                            <td>üî¢ Number</td>
                            <td>Nombre qui d√©file puis s'arr√™te</td>
                        </tr>
                        <tr>
                            <td>‚è∏ Pause</td>
                            <td>Pause configurable (d√©faut 2s)</td>
                        </tr>
                        <tr>
                            <td>üéØ Pinpoint</td>
                            <td>Cible qui se resserre sur un point</td>
                        </tr>
                        <tr>
                            <td>üíì Pulse</td>
                            <td>Pulsation hypnotique de l'√©cran</td>
                        </tr>
                        <tr>
                            <td>üß© Puzzle</td>
                            <td>Pi√®ces de puzzle qui s'assemblent</td>
                        </tr>
                        <tr>
                            <td>üé¥ Reveal</td>
                            <td>R√©v√©lation d'UNE carte (ex: 9C)</td>
                        </tr>
                        <tr>
                            <td>üñºÔ∏è RevealImage</td>
                            <td>R√©v√©lation d'une image/photo (URL)</td>
                        </tr>
                        <tr>
                            <td>„Ä∞Ô∏è Ripple</td>
                            <td>Ondulation depuis le centre</td>
                        </tr>
                        <tr>
                            <td>„Ä∞Ô∏è RippleFromLogo</td>
                            <td>Ondulation depuis le logo</td>
                        </tr>
                        <tr>
                            <td>üì£ Shake</td>
                            <td>Tremblement de l'√©cran</td>
                        </tr>
                        <tr>
                            <td>üîÄ Shuffle</td>
                            <td>M√©lange rapide de cartes</td>
                        </tr>
                        <tr>
                            <td>üîá Silence</td>
                            <td>Coupe tous les sons</td>
                        </tr>
                        <tr>
                            <td>üé∞ Slot</td>
                            <td>Machine √† sous (3 symboles)</td>
                        </tr>
                        <tr>
                            <td>üì∏ Snapshot</td>
                            <td>Flash cam√©ra + freeze frame</td>
                        </tr>
                        <tr>
                            <td>‚ú® Sparkle</td>
                            <td>Paillettes qui tombent</td>
                        </tr>
                        <tr>
                            <td>üåÄ Spiral</td>
                            <td>Spirale tournante hypnotique</td>
                        </tr>
                        <tr>
                            <td>üåü Starfield</td>
                            <td>Champ d'√©toiles en mouvement</td>
                        </tr>
                        <tr>
                            <td>üìª StaticNoise</td>
                            <td>Bruit blanc TV/static</td>
                        </tr>
                        <tr>
                            <td>‚èπ Stop</td>
                            <td>Stoppe la s√©quence (reset manuel)</td>
                        </tr>
                        <tr>
                            <td>üìù Text</td>
                            <td>Texte g√©ant personnalisable</td>
                        </tr>
                        <tr>
                            <td>üîì Unlock</td>
                            <td>Cadenas qui s'ouvre</td>
                        </tr>
                        <tr>
                            <td>üé¨ Video</td>
                            <td>Vid√©o plein √©cran (URL)</td>
                        </tr>
                        <tr>
                            <td>üåä Wave</td>
                            <td>Vague liquide qui traverse l'√©cran</td>
                        </tr>
                        <tr>
                            <td>üî§ Words</td>
                            <td>Lettres ‚Üí mots ‚Üí MOT FINAL</td>
                        </tr>
                        <tr>
                            <td>üîç Zoom</td>
                            <td>Zoom progressif sur l'√©cran</td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="step-add-area"></div>
            <div id="steps-list"></div>

            <div class="section-title">Configuration Globale</div>
            <div class="row"><label>D√©lai d'Entr√©e (s)</label><input type="number" id="delay-input" value="2"
                    step="0.5">
            </div>
            <div class="row">
                <div class="setting-row">
                    <label for="logo-zoom-input">Zoom Logo: <span id="zoom-val">100</span>%</label>
                    <input type="range" id="zoom-range" min="10" max="500" value="100" oninput="updateZoom(this.value)"
                        onmousedown="document.getElementById('settings-panel').style.opacity='0.3'"
                        onmouseup="document.getElementById('settings-panel').style.opacity='1'"
                        ontouchstart="document.getElementById('settings-panel').style.opacity='0.3'"
                        ontouchend="document.getElementById('settings-panel').style.opacity='1'">
                </div>
                <div class="setting-row">
                    <label>Image d'accueil:</label>
                    <div style="display:flex; gap:10px; margin-bottom:5px;">
                        <label><input type="radio" name="startImgSrc" value="logo" onchange="setStartImgSource('logo')"
                                checked> Logo</label>
                        <label><input type="radio" name="startImgSrc" value="custom"
                                onchange="setStartImgSource('custom')"> Autre</label>
                    </div>
                    <div id="custom-start-img-container" style="display:none;">
                        <input type="file" id="custom-start-file" onchange="handleStartImageUpload(this)">
                        <input type="text" id="start-img-url-input" placeholder="URL Image..."
                            onchange="updateStartImage(this.value)">
                    </div>
                </div>
                <div class="setting-row">
                    <label>Textes d'accueil:</label>
                    <input type="text" id="welcome-text-input" placeholder="TOUCHER POUR COMMENCER"
                        onchange="updateTexts()">
                    <input type="text" id="sub-text-input" placeholder="Exp√©rience Interactive" onchange="updateTexts()"
                        style="margin-top:5px;">
                </div>
                <div class="setting-row">
                    <label for="logo-url-input">URL Logo:</label>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="logo-url-input" placeholder="http://..."
                            onchange="previewLogo(this.value)">
                        <input type="file" id="logo-file" accept="image/*" style="width:110px;"
                            onchange="handleFileUpload(this)">
                    </div>
                </div>
            </div>
            <div class="row"><label>URL Redirection Finale</label><input type="text" id="redir-url-input"
                    placeholder="https://g.page/..."></div>
            <div class="row"><label>Texte d'accueil</label><input type="text" id="tagline-input"
                    placeholder="R√©aliser une exp√©rience."></div>
            <div class="row">
                <label for="logs-toggle">Afficher les logs de timing (Admin)</label>
                <label class="switch" style="margin:0;">
                    <input type="checkbox" id="logs-toggle" onchange="toggleLogs(this.checked)">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="row">
                <label for="toggle-debug">Mode Debug (Visible sur public)</label>
                <label class="switch" style="margin:0;">
                    <input type="checkbox" id="toggle-debug">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="row">
                <div class="setting-row">
                    <label for="bg-color-input">Couleur de fond:</label>
                    <div style="display:flex; gap:5px; align-items:center;">
                        <input type="color" id="bg-color-input" onchange="setBgColor(this.value)">
                        <button onclick="autoColorFromLogo()"
                            style="font-size:12px; padding:2px 8px; border:1px solid #555; background:#333; color:#fff; border-radius:4px; cursor:pointer;"
                            title="Extraire du logo">üé® Auto</button>
                    </div>
                </div>
                <div class="setting-row">
                    <label for="bg-anim-select">Animation de fond:</label>
                    <select id="bg-anim-select" onchange="setBgAnim(this.value)" style="padding:5px;border-radius:4px;">
                        <option value="none">Aucune</option>
                        <option value="particles">Particules</option>
                        <option value="gradient">D√©grad√©</option>
                        <option value="stars">√âtoiles</option>
                        <option value="matrix">Matrix</option>
                        <option value="fireflies">Lucioles</option>
                        <option value="bokeh">Bokeh</option>
                        <option value="plasma">Plasma</option>
                        <option value="snow">Neige</option>
                        <option value="rain">Pluie</option>
                        <option value="geometric">G√©om√©trique</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label for="start-anim-select">Anim. D√©part:</label>
                    <select id="start-anim-select" onchange="setStartAnim(this.value)"
                        style="padding:5px;border-radius:4px;">
                        <option value="fade">Fondu (D√©faut)</option>
                        <option value="zoom">Zoom</option>
                        <option value="slide">Glisser Haut</option>
                        <option value="none">Aucune</option>
                    </select>
                </div>
            </div>

            <div class="section-title">Outils</div>
            <div class="row" style="flex-direction:column;align-items:flex-start;">
                <label>G√©n√©rateur QR Code (Vers Public)</label>
                <div style="display:flex;gap:20px;margin-top:10px;align-items:flex-start;width:100%;">
                    <div id="qr-container"
                        style="background:#fff;padding:15px;border-radius:12px;min-width:200px;min-height:200px;display:flex;justify-content:center;align-items:center;">
                        <span style="color:#ccc;font-size:12px;">QR Code ici</span>
                    </div>
                    <div style="display:flex;flex-direction:column;gap:10px;flex:1;">
                        <p style="font-size:12px;color:#aaa;margin-bottom:5px;">Le QR dirigera vers l'URL actuelle (sans
                            /admin.html). Le logo actif sera incrust√©.</p>
                        <button class="btn btn-secondary" onclick="generateQR()">üîÑ G√©n√©rer</button>
                        <button class="btn btn-secondary" onclick="downloadQR()"
                            style="background:#34c759;color:#fff;">üíæ T√©l√©charger HD</button>
                    </div>
                </div>
                <canvas id="qr-canvas" style="display:none;"></canvas>
            </div>

            <button class="btn" style="background:#34c759" onclick="saveAll()">SYNCHRONISER &
                ENREGISTRER</button>
            <button class="btn btn-secondary" onclick="closePanel()">FERMER PANNEAU</button>
        </div>
    </div>
    <!-- End Settings Panel -->

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        const socket = io();
        let serverOffset = 0;
        let state = {};
        let hasStarted = false;
        const logBox = null; // D√©sactiv√©

        function log(msg) {
            const time = new Date().toLocaleTimeString();
            console.log(`[PUBLIC ${time}] ${msg}`);
            // Nettoyage complet : plus d'√©criture dans le DOM
        }

        // === ANTI-VEILLE (silence.mp4 + WakeLock API) ===
        let noSleepVideo = null;
        let wakeLockSentinel = null;
        let noSleepActive = false;

        function createNoSleepVideo() {
            const v = document.createElement('video');
            v.setAttribute('playsinline', '');
            v.setAttribute('muted', '');
            v.setAttribute('loop', '');
            v.muted = true;
            v.style.cssText = 'position:fixed;top:-1px;left:-1px;width:1px;height:1px;opacity:0.01;pointer-events:none;z-index:-1;';
            v.src = 'silence.mp4';
            document.body.appendChild(v);
            return v;
        }

        function enableNoSleep() {
            if (noSleepActive) return;
            // Vid√©o silence.mp4 (fonctionne sur iOS Safari)
            if (!noSleepVideo) noSleepVideo = createNoSleepVideo();
            const p = noSleepVideo.play();
            if (p) p.then(() => {
                noSleepActive = true;
                // log("NoSleep vid√©o activ√© ‚úì"); // Silencieux
            }).catch(e => {
                // Silencieux pour le public
                console.log("NoSleep vid√©o non support√© (normal sur desktop)");
            });
            // Bonus: WakeLock API (Chrome, Safari 16.4+)
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').then(s => {
                    wakeLockSentinel = s;
                    log("WakeLock API activ√© ‚úì");
                    s.addEventListener('release', () => { log("WakeLock rel√¢ch√©"); });
                }).catch(() => { });
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && hasStarted) {
                enableNoSleep();
            }
        });

        // === PRELOADING LOGIC ===
        function preloadAllAssets() {
            if (!state || !state.routines) return;
            log("üöÄ Pr√©chargement des assets...");
            const assets = [];

            // Collect assets
            state.routines.forEach(routine => {
                routine.steps.forEach(step => {
                    if (step.url) assets.push({ url: step.url, type: step.type });
                    if (step.value && (step.type === 'reveal' || step.type === 'cardFlip')) {
                        let val = step.value;
                        if (!val.includes('/')) val = 'cards/' + val + (val.endsWith('.jpg') ? '' : '.jpg');
                        assets.push({ url: val, type: 'image' });
                    }
                    if (step.images && Array.isArray(step.images)) {
                        step.images.forEach(img => assets.push({ url: img, type: 'image' }));
                    }
                });
            });

            // Unique assets
            const unique = [...new Set(assets.map(JSON.stringify))].map(JSON.parse);

            unique.forEach(asset => {
                const url = asset.url;
                if (!url) return;

                if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i) || asset.type === 'image') {
                    const img = new Image();
                    img.src = url;
                } else if (url.match(/\.(mp3|wav|ogg)$/i) || asset.type === 'audio') {
                    const a = new Audio();
                    a.src = url;
                    a.load();
                } else if (url.match(/\.(mp4|webm)$/i) || asset.type === 'video') {
                    const v = document.createElement('video');
                    v.src = url;
                    v.preload = 'auto';
                    v.load();
                }
            });
            log(`üì¶ ${unique.length} fichiers mis en cache.`);
        }

        // === INTERACTIVE CONNECT ===
        document.getElementById('connect-wrapper').addEventListener('click', () => {
            // Unlock Audio Context
            const audioEl = document.getElementById('audio-player');
            if (audioEl) {
                audioEl.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
                audioEl.play().catch(e => console.log("Audio unlock failed/blocked", e));
            }

            // Trigger Preload
            preloadAllAssets();

            // Trigger Preload
            preloadAllAssets();

            hasStarted = true;
            document.getElementById('connect-screen').classList.remove('active');
            document.getElementById('logo-screen').classList.add('active');

            log("Exp√©rience d√©marr√©e ‚úì (Preloading ON)");
            enableNoSleep();
            updateLogoDisplay();
        });



        // === CONNEXION SOCKET ===
        socket.on('connect', () => {
            log("VERSION: v5.0 - Single URL");
            log("Connect√©: " + socket.id);
            const now = Date.now();
            socket.emit('sync-time', now, (serverTime) => {
                const latency = (Date.now() - now) / 2;
                serverOffset = serverTime - (Date.now() - latency);
                log("Offset serveur: " + serverOffset + "ms");
            });
        });

        socket.on('disconnect', () => log("D√©connect√© du serveur!"));

        socket.on('spectator-count', (data) => log("Spectateurs: " + data.count));

        socket.on('state-update', (serverState) => {
            state = serverState;
            log("State re√ßu: " + (state.routines ? state.routines.length : 0) + " routines, logo=" + (state.logoVisible ? "visible" : "cach√©"));
            updateLogoDisplay();
            updateConnectScreen(); // Update connect logo if customized
            document.getElementById('redirection-btn').href = state.redirectionUrl || '#';
            // Apply background color/animation
            if (state.bgColor) {
                document.body.style.backgroundColor = state.bgColor;
            }
            if (state.bgAnim) {
                setBgAnimation(state.bgAnim, state.bgColor || '#000000');
            }
            // Pre-set start anim state if needed (though mostly used on click)
            if (state.startAnim) {
                // Store locally if helpful, or just access state.startAnim directly in click handler
            }
        });

        // === BACKGROUND ANIMATIONS ===
        let bgCanvas = document.getElementById('bg-canvas');
        let bgCtx = bgCanvas.getContext('2d');
        let bgAnimFrameId = null;
        let bgParticles = [];

        function resizeBgCanvas() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeBgCanvas);
        resizeBgCanvas();

        function setBgAnimation(type, color) {
            // Reset
            cancelAnimationFrame(bgAnimFrameId);
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            document.getElementById('bg-overlay-css').className = '';
            document.getElementById('bg-overlay-css').style = 'position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;pointer-events:none;';
            bgParticles = [];

            log("Background Anim: " + type);

            switch (type) {
                case 'none':
                    break;
                case 'particles':
                    initParticles(color);
                    break;
                case 'gradient':
                    const cssEl = document.getElementById('bg-overlay-css');
                    cssEl.style.background = `linear-gradient(45deg, ${color}, #000, ${color})`;
                    cssEl.style.backgroundSize = '400% 400%';
                    cssEl.style.animation = 'gradientBG 15s ease infinite';
                    if (!document.getElementById('style-gradient')) {
                        const s = document.createElement('style');
                        s.id = 'style-gradient';
                        s.innerHTML = `@keyframes gradientBG { 0% {background-position: 0% 50%;} 50% {background-position: 100% 50%;} 100% {background-position: 0% 50%;} }`;
                        document.head.appendChild(s);
                    }
                    break;
                case 'stars':
                    initStarfield();
                    break;
                case 'matrix':
                    initMatrix(color);
                    break;
                case 'fireflies':
                    initFireflies(color);
                    break;
                case 'bokeh':
                    initBokeh(color);
                    break;
                case 'plasma':
                    initPlasma(color);
                    break;
                case 'snow':
                    initSnow();
                    break;
                case 'rain':
                    initRain(color);
                    break;
                case 'geometric':
                    initGeometric(color);
                    break;
                // Add more as needed
            }
        }

        // --- Animation Implementations ---
        function initParticles(color) {
            for (let i = 0; i < 100; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vx: (Math.random() - 0.5) * 1,
                    vy: (Math.random() - 0.5) * 1,
                    size: Math.random() * 3 + 1,
                    alpha: Math.random()
                });
            }
            function loop() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.fillStyle = color;
                bgParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0) p.x = bgCanvas.width;
                    if (p.x > bgCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = bgCanvas.height;
                    if (p.y > bgCanvas.height) p.y = 0;
                    bgCtx.globalAlpha = p.alpha;
                    bgCtx.beginPath();
                    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initMatrix(color) {
            const cols = Math.floor(bgCanvas.width / 20);
            const ypos = Array(cols).fill(0);
            bgCtx.fillStyle = '#000';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            function loop() {
                bgCtx.fillStyle = '#0001'; // Fade trail
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

                bgCtx.fillStyle = color || '#0f0';
                bgCtx.font = '15pt monospace';

                ypos.forEach((y, ind) => {
                    const text = String.fromCharCode(Math.random() * 128);
                    const x = ind * 20;
                    bgCtx.fillText(text, x, y);
                    if (y > 100 + Math.random() * 10000) ypos[ind] = 0;
                    else ypos[ind] = y + 20;
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initStarfield() {
            for (let i = 0; i < 200; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    z: Math.random() * bgCanvas.width
                });
            }
            function loop() {
                bgCtx.fillStyle = '#000';
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height); // Clear
                bgCtx.fillStyle = '#fff';

                const cx = bgCanvas.width / 2;
                const cy = bgCanvas.height / 2;

                bgParticles.forEach(p => {
                    p.z -= 2; // Speed
                    if (p.z <= 0) {
                        p.z = bgCanvas.width;
                        p.x = Math.random() * bgCanvas.width;
                        p.y = Math.random() * bgCanvas.height;
                    }
                    const k = 128.0 / p.z;
                    const x = (p.x - cx) * k + cx;
                    const y = (p.y - cy) * k + cy;

                    if (x >= 0 && x < bgCanvas.width && y >= 0 && y < bgCanvas.height) {
                        bgCtx.beginPath();
                        bgCtx.arc(x, y, (1 - p.z / bgCanvas.width) * 3, 0, Math.PI * 2);
                        bgCtx.fill();
                    }
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initFireflies(color) {
            // Similar to particles but glows
            for (let i = 0; i < 50; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 2 + 1,
                    phase: Math.random() * Math.PI * 2
                });
            }
            function loop() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.phase += 0.05;
                    const alpha = (Math.sin(p.phase) + 1) / 2 * 0.8 + 0.2;

                    if (p.x < 0) p.x = bgCanvas.width;
                    if (p.x > bgCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = bgCanvas.height;
                    if (p.y > bgCanvas.height) p.y = 0;

                    bgCtx.shadowBlur = 10;
                    bgCtx.shadowColor = color;
                    bgCtx.fillStyle = color;
                    bgCtx.globalAlpha = alpha;
                    bgCtx.beginPath();
                    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.shadowBlur = 0;
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initBokeh(color) {
            // Large blurry circles
            for (let i = 0; i < 20; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vx: (Math.random() - 0.5) * 0.2,
                    vy: (Math.random() - 0.5) * 0.2,
                    size: Math.random() * 50 + 20,
                    alpha: Math.random() * 0.2 + 0.05
                });
            }
            function loop() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < -100) p.x = bgCanvas.width + 100;
                    if (p.x > bgCanvas.width + 100) p.x = -100;
                    if (p.y < -100) p.y = bgCanvas.height + 100;
                    if (p.y > bgCanvas.height + 100) p.y = -100;

                    bgCtx.fillStyle = color;
                    bgCtx.globalAlpha = p.alpha;
                    bgCtx.beginPath();
                    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initPlasma(color) {
            let t = 0;
            function loop() {
                t += 0.01;
                // Expensive for full pixel manipulation, let's use a simplified approach or just clear
                // Plasma usually requires pixel manipulation which is slow in JS for full screen.
                // Let's draw moving sine waves.
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.strokeStyle = color;
                bgCtx.lineWidth = 2;

                for (let i = 0; i < 5; i++) {
                    bgCtx.beginPath();
                    for (let x = 0; x < bgCanvas.width; x += 10) {
                        const y = bgCanvas.height / 2 + Math.sin(x * 0.01 + t + i) * 100 * Math.sin(t * 0.5);
                        if (x === 0) bgCtx.moveTo(x, y); else bgCtx.lineTo(x, y);
                    }
                    bgCtx.stroke();
                }
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initSnow() {
            for (let i = 0; i < 150; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: Math.random() * 2 + 1,
                    size: Math.random() * 2 + 1
                });
            }
            function loop() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.fillStyle = '#fff';
                bgParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.y > bgCanvas.height) {
                        p.y = -5;
                        p.x = Math.random() * bgCanvas.width;
                    }
                    if (p.x > bgCanvas.width) p.x = 0;
                    if (p.x < 0) p.x = bgCanvas.width;

                    bgCtx.beginPath();
                    bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initRain(color) {
            for (let i = 0; i < 300; i++) {
                bgParticles.push({
                    x: Math.random() * bgCanvas.width,
                    y: Math.random() * bgCanvas.height,
                    vy: Math.random() * 10 + 10,
                    l: Math.random() * 20 + 10
                });
            }
            function loop() {
                bgCtx.fillStyle = '#0003'; // trail
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.strokeStyle = color || '#0af';
                bgCtx.lineWidth = 1;
                bgCtx.beginPath();
                bgParticles.forEach(p => {
                    p.y += p.vy;
                    if (p.y > bgCanvas.height) {
                        p.y = -p.l;
                        p.x = Math.random() * bgCanvas.width;
                    }
                    bgCtx.moveTo(p.x, p.y);
                    bgCtx.lineTo(p.x, p.y + p.l);
                });
                bgCtx.stroke();
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        function initGeometric(color) {
            let t = 0;
            function loop() {
                t += 0.005;
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                bgCtx.strokeStyle = color;
                bgCtx.lineWidth = 1;

                const cx = bgCanvas.width / 2;
                const cy = bgCanvas.height / 2;

                for (let i = 0; i < 10; i++) {
                    const size = 100 + i * 50;
                    bgCtx.save();
                    bgCtx.translate(cx, cy);
                    bgCtx.rotate(t * (i % 2 === 0 ? 1 : -1) + i * 0.1);
                    bgCtx.strokeRect(-size / 2, -size / 2, size, size);
                    bgCtx.restore();
                }
                bgAnimFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

        // === END BG ANIMATIONS ===

        function updateConnectScreen() {
            // Start Image
            const logoEl = document.getElementById('connect-logo');
            let hasImage = false;

            if (state.startImageSource === 'custom' && state.startImageUrl) {
                logoEl.src = state.startImageUrl;
                hasImage = true;
            } else if (state.logoUrl) {
                logoEl.src = state.logoUrl;
                hasImage = true;
            }

            if (hasImage) {
                logoEl.style.display = 'block';
                // Apply Zoom to Start Image (Base 150px * Zoom/100)
                // Use Width to control size so it reflows correctly in flex container
                const zoom = state.logoZoom || 100;
                // Base width 150px at 100% zoom
                logoEl.style.width = (150 * (zoom / 100)) + 'px';
                logoEl.style.height = (150 * (zoom / 100)) + 'px';
                logoEl.style.display = 'none';
            }

            // Texts
            const wText = state.welcomeText || '';
            const wEl = document.getElementById('welcome-text');
            if (wText.trim()) {
                wEl.innerText = wText;
                wEl.style.display = 'block';
            } else {
                wEl.style.display = 'none';
            }

            const sText = state.subText || '';
            const sEl = document.getElementById('sub-text');
            if (sEl) {
                if (sText.trim()) {
                    sEl.innerText = sText;
                    sEl.style.display = 'block';
                } else {
                    sEl.style.display = 'none';
                }
            }
        }

        function updateLogoDisplay() {
            if (!hasStarted) return;
            const img = document.getElementById('logo-img');
            if (state.logoUrl && state.logoVisible) {
                img.src = state.logoUrl;
                img.style.display = 'block';
                img.style.transform = `scale(${(state.logoZoom || 100) / 100})`;
                log("Logo affich√© (zoom " + (state.logoZoom || 100) + "%)");
            } else {
                img.style.display = 'none';
            }
            // Tagline personnalisable
            const tagline = document.getElementById('tagline-text');
            if (tagline && state.tagline) tagline.innerText = state.tagline;
        }

        // === S√âQUENCE ===
        socket.on('start-sequence', (data) => {
            log("S√©quence re√ßue! " + data.routine.name + " (" + data.routine.steps.length + " √©tapes)");
            runRoutine(data.routine, data.targetTime);
        });

        socket.on('reset-sequence', () => { log("Reset re√ßu"); window.location.reload(); });

        async function runRoutine(routine, targetTime) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('engine-screen').classList.add('active');
            log("Moteur d√©marr√©, attente sync...");
            window.hasLoggedDelay = false;

            let currentStepIdx = 0;
            let stepStartTime = targetTime;
            const update = () => {
                const now = Date.now() + serverOffset;
                if (now < targetTime) {
                    requestAnimationFrame(update);
                    return;
                }

                // Catch-up logic: if we are late, we might need to skip steps or fast-forward
                // But for now, we just ensure we start.
                if (currentStepIdx === 0 && stepStartTime === targetTime && (now - targetTime) > 100) {
                    if (!window.hasLoggedDelay) {
                        log("Retard au d√©marrage: " + (now - targetTime) + "ms (Catch-up)");
                        window.hasLoggedDelay = true;
                    }
                }

                const steps = routine.steps.filter(s => s.active);
                if (currentStepIdx >= steps.length) { finishRoutine(); return; }

                const step = steps[currentStepIdx];
                const elapsedInStep = now - stepStartTime;

                if (elapsedInStep === 0 || (currentStepIdx > 0 && elapsedInStep < 100)) {
                    log("Step " + (currentStepIdx + 1) + "/" + steps.length + ": " + step.type + " (" + step.duration + "ms)");
                }
                // Log timing every second
                if (elapsedInStep > 0 && elapsedInStep % 1000 < 20) {
                    log("  ‚è± " + step.type + ": " + (elapsedInStep / 1000).toFixed(1) + "s / " + (step.duration / 1000).toFixed(1) + "s");
                }

                renderStep(step, now, elapsedInStep);

                if (elapsedInStep >= step.duration) {
                    currentStepIdx++;
                    stepStartTime = now;
                    log("  ‚úì " + step.type + " termin√© en " + (elapsedInStep / 1000).toFixed(1) + "s");

                    // Gestion de la persistance (Overlay)
                    if (step.persist) {
                        log("  ‚Üí Persist: ON (L'√©cran n'est pas effac√©)");
                    } else {
                        log("  ‚Üí Persist: OFF (√âcran effac√©)");
                        document.getElementById('emoji-display').innerText = '';
                        document.getElementById('media-display').style.display = 'none';
                        document.getElementById('video-display').style.display = 'none';
                        document.getElementById('arrow').style.display = 'none';
                        document.getElementById('main-body').className = '';
                        document.getElementById('main-body').style.animation = '';
                        document.getElementById('main-body').style.removeProperty('--breathing-color');
                        // Reset overlays and specific displays
                        document.querySelectorAll('.screen > div[id$="-overlay"], .screen > div[id$="-container"], #countdown-display, #text-display, #number-display, #crystal-ball, #unlock-icon, #reveal-image-display').forEach(el => {
                            if (el.id !== 'debug-log') el.style.display = 'none';
                        });
                    }
                }
                requestAnimationFrame(update);
            };
            requestAnimationFrame(update);
        }

        function renderStep(step, now, elapsed) {
            const body = document.getElementById('main-body');
            const emojiDiv = document.getElementById('emoji-display');
            const mediaImg = document.getElementById('media-display');
            const videoVid = document.getElementById('video-display');

            switch (step.type) {
                case 'blackout':
                    body.className = 'blackout-bg';
                    break;
                case 'flash':
                    const flashDuration = step.duration;
                    const flashCount = step.value || 1; // Default to 1 flash if not specified
                    const singleFlashDur = flashDuration / flashCount;

                    if (step.active === false) { // Clean up if inactive
                        body.classList.remove('flash-bg', 'flash-strobe');
                        break;
                    }

                    // Calculate current cycle in the sequence
                    const currentCycle = Math.floor(elapsed / singleFlashDur);
                    const cycleProgress = (elapsed % singleFlashDur) / singleFlashDur;

                    // Flash is ON for first 50% of each cycle
                    if (currentCycle < flashCount && cycleProgress < 0.5) {
                        body.classList.add('flash-bg');
                        if (step.color) body.style.backgroundColor = step.color;
                        if (step.vibrate && cycleProgress < 0.1) navigator.vibrate(50); // Vibrate at start of each flash
                    } else {
                        body.classList.remove('flash-bg');
                        body.style.backgroundColor = '';
                    }
                    break;
                case 'emojis':
                    const t = Math.min(1, elapsed / step.duration);
                    const startSpeed = step.speed || 1200;
                    const interval = startSpeed * Math.pow(0.25, t);
                    const emojis = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô£Ô∏è', '‚ô¶Ô∏è'];
                    const emojiIndex = Math.floor(now / interval) % 4;
                    const emoji = emojis[emojiIndex];

                    // Randomize Layout based on CURRENT EMOJI INDEX + step.id
                    // This ensures each suit appears in a different random spot
                    const seedE = (step.id || 12345) + emojiIndex * 137;
                    const rngE = (o) => { const x = Math.sin(seedE + o) * 10000; return x - Math.floor(x); };

                    emojiDiv.style.position = 'absolute';
                    emojiDiv.style.top = (20 + rngE(0) * 60) + '%';
                    emojiDiv.style.left = (10 + rngE(1) * 80) + '%';
                    emojiDiv.style.fontSize = (10 + rngE(2) * 15) + 'vh';
                    // Apply rotation and transform
                    emojiDiv.style.transform = `translate(-50%, -50%) rotate(${rngE(3) * 40 - 20}deg)`;

                    emojiDiv.innerText = emoji;
                    emojiDiv.className = (emoji === '‚ô•Ô∏è' || emoji === '‚ô¶Ô∏è') ? 'red' : 'black';
                    break;
                case 'shuffle':
                    body.className = 'white-bg';
                    mediaImg.style.display = 'block';
                    const cards = ['AS', 'KH', '2J', 'QC', '7H', '3C'];
                    mediaImg.src = `cards/${cards[Math.floor(now / (step.speed || 150)) % cards.length]}.jpg`;
                    break;
                case 'reveal':
                    body.className = 'white-bg';
                    mediaImg.style.display = 'block';
                    mediaImg.src = `cards/${step.value}.jpg`;
                    break;
                case 'video':
                    videoVid.style.display = 'block';
                    // Initialisation s√©curis√©e via attribut data
                    if (videoVid.getAttribute('data-current-url') !== step.url) {
                        videoVid.setAttribute('data-current-url', step.url);
                        videoVid.src = step.url;
                        videoVid.loop = !!step.loop;
                        videoVid.load();

                        // Tentative de calage imm√©diat
                        const startOffset = elapsed / 1000;
                        if (startOffset > 0) videoVid.currentTime = startOffset;

                        videoVid.play().catch(e => console.log("Video autoplay blocked/error", e));
                    } else {
                        // Sync Loop : si d√©calage > 0.5s, on recale (utile si buffering ou retard chargement)
                        const targetTime = elapsed / 1000;
                        if (!videoVid.paused && !videoVid.seeking && Math.abs(videoVid.currentTime - targetTime) > 0.5) {
                            console.log(`Resync video: ${videoVid.currentTime.toFixed(2)} -> ${targetTime.toFixed(2)}`);
                            videoVid.currentTime = targetTime;
                        }
                    }
                    break;
                case 'lottie':
                    const lottieDiv = document.getElementById('lottie-display');
                    lottieDiv.style.display = 'block';
                    try {
                        const currentUrl = lottieDiv.getAttribute('data-current-url');
                        const currentLoop = lottieDiv.getAttribute('data-loop') === 'true';
                        const targetLoop = !!step.loop;

                        if (currentUrl !== step.url || currentLoop !== targetLoop) {
                            lottieDiv.setAttribute('data-current-url', step.url);
                            lottieDiv.setAttribute('data-loop', targetLoop);
                            lottieDiv.innerHTML = ''; // Clear previous
                            if (typeof lottie !== 'undefined') {
                                lottie.loadAnimation({
                                    container: lottieDiv,
                                    renderer: 'svg',
                                    loop: targetLoop,
                                    autoplay: true,
                                    path: step.url
                                });
                            } else {
                                console.error("Lottie library not loaded");
                            }
                        }
                    } catch (e) { console.error(e); }
                    break;
                case 'words':
                    // Reset position for words (center)
                    emojiDiv.style.position = 'absolute';
                    emojiDiv.style.top = '50%';
                    emojiDiv.style.left = '50%';
                    emojiDiv.style.transform = 'translate(-50%, -50%)';
                    emojiDiv.style.fontSize = '8vh';
                    emojiDiv.className = '';
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                    const wordList = (step.words || []).length > 0 ? step.words : ['MAGIE', 'MYST√àRE', 'ILLUSION'];
                    const finalWord = step.value || wordList[wordList.length - 1];
                    const lPctRaw = (step.letterPct || 60) / 100;
                    const wPctRaw = (step.wordPct || 30) / 100;
                    // Auto-clamp: toujours r√©server au moins 10% pour le mot final
                    const totalPct = lPctRaw + wPctRaw;
                    const lPct = totalPct >= 0.95 ? lPctRaw * 0.85 / totalPct : lPctRaw;
                    const wPct = totalPct >= 0.95 ? wPctRaw * 0.85 / totalPct : wPctRaw;
                    const sSpeed = step.startSpeed || 800;
                    const eSpeed = step.endSpeed || 120;
                    const fSize = step.finalSize || 10;
                    const pMs = step.pauseMs || 2000;
                    const progress = Math.min(1, elapsed / step.duration);
                    if (progress < lPct) {
                        const p = progress / lPct;
                        const speed = sSpeed * Math.pow(eSpeed / sSpeed, p);
                        emojiDiv.innerText = alphabet[Math.floor(now / speed) % 26];
                    } else if (progress < lPct + wPct) {
                        const p = (progress - lPct) / wPct;
                        const speed = (sSpeed * 0.75) * Math.pow(eSpeed / (sSpeed * 0.75), p);
                        const idx = Math.floor(now / speed) % wordList.length;
                        emojiDiv.innerText = wordList[idx];
                    } else {
                        emojiDiv.innerText = finalWord;
                        emojiDiv.style.fontSize = fSize + 'vh';
                    }
                    break;
                case 'heart':
                    const heartSvg = document.getElementById('heart-svg');
                    heartSvg.style.display = 'block';
                    heartSvg.classList.add('active');
                    setTimeout(() => {
                        heartSvg.classList.remove('active');
                        heartSvg.style.display = 'none';
                    }, 3000);
                    break;
                case 'dice':
                    const diceContainer = document.getElementById('dice-container');
                    const diceEl = document.getElementById('dice');
                    diceContainer.style.display = 'block';
                    if (elapsed < 2000) {
                        diceEl.style.animation = 'diceRoll 2s ease-out forwards';
                    } else {
                        const finalFace = step.value || step.finalFace || 6;
                        const rotations = {
                            1: 'rotateY(0deg) rotateX(0deg)',
                            2: 'rotateY(180deg) rotateX(0deg)',
                            3: 'rotateY(90deg) rotateX(0deg)',
                            4: 'rotateY(-90deg) rotateX(0deg)',
                            5: 'rotateY(0deg) rotateX(90deg)',
                            6: 'rotateY(0deg) rotateX(-90deg)'
                        };
                        diceEl.style.transform = rotations[finalFace] || rotations[6];
                        diceEl.style.animation = 'none';
                    }
                    break;
                case 'rippleFromLogo':
                    const ripple = document.getElementById('ripple-overlay');
                    const logoImg = document.querySelector('#logo-screen img');
                    if (logoImg && elapsed === 0) {
                        const rect = logoImg.getBoundingClientRect();
                        ripple.style.left = (rect.left + rect.width / 2) + 'px';
                        ripple.style.top = (rect.top + rect.height / 2) + 'px';
                    }
                    ripple.style.display = 'block';
                    ripple.classList.add('active');
                    setTimeout(() => {
                        ripple.classList.remove('active');
                        ripple.style.display = 'none';
                    }, step.duration);
                    break;
                case 'audio':
                    const audioEl = document.getElementById('audio-player');
                    if (!step._audioStarted) {
                        step._audioStarted = true; // Mark as started
                        let url = step.url || '';
                        // Fix for absolute paths in case they sneak in
                        if (url.includes('/public/audio/')) {
                            url = 'audio/' + url.split('/public/audio/')[1];
                        } else if (url.includes('\\public\\audio\\')) {
                            url = 'audio/' + url.split('\\public\\audio\\')[1];
                        }
                        console.log(`[AUDIO DEBUG] Playing URL: ${url}`);
                        log(`Audio URL: ${url}`);
                        audioEl.src = url;
                        audioEl.loop = !!step.loop;
                        audioEl.volume = (step.startVol || 50) / 100;
                        audioEl.play()
                            .then(() => log("Audio d√©marr√© !"))
                            .catch(e => {
                                console.error("Audio error:", e);
                                log(`Audio blocked/error: ${e.message}`, "#f00");
                            });
                    }
                    const startVol = (step.startVol || 50) / 100;
                    const endVol = (step.endVol || 100) / 100;
                    const fadeMs = step.fadeMs || step.duration;
                    const volProgress = Math.min(elapsed / fadeMs, 1);
                    audioEl.volume = startVol + (endVol - startVol) * volProgress;
                    break;
                case 'text':
                    const textDiv = document.getElementById('text-display');
                    textDiv.style.display = 'block';
                    textDiv.innerText = step.value || 'TEXTE';
                    textDiv.style.color = step.color || '#ffffff';
                    textDiv.style.fontSize = (step.size || 12) + 'vh';
                    // New Params
                    textDiv.style.textAlign = step.align || 'center';
                    textDiv.style.fontFamily = step.font || 'sans-serif';
                    textDiv.style.fontWeight = step.bold ? 'bold' : 'normal';
                    break;
                case 'pulse':
                    body.classList.add('pulse-bg');
                    // Note: pulse-bg uses CSS animation, color/speed would need extra inline styles or CSS var
                    if (step.color) body.style.setProperty('--pulse-color', step.color);
                    if (step.speed) body.style.animationDuration = step.speed + 'ms';
                    break;
                case 'spiral':
                    const spiralDiv = document.getElementById('spiral-overlay');
                    spiralDiv.style.display = 'block';
                    spiralDiv.classList.add('active');
                    if (step.speed) spiralDiv.style.animationDuration = step.speed + 'ms';
                    break;
                case 'color':
                    const colorDiv = document.getElementById('color-overlay');
                    colorDiv.style.display = 'block';
                    colorDiv.style.backgroundColor = step.value || '#ff0000';
                    break;
                case 'number':
                    const numberDiv = document.getElementById('number-display');
                    numberDiv.style.display = 'block';

                    // Randomize Layout
                    const seedN = step.id || 67890;
                    const rngN = (o) => { const x = Math.sin(seedN + o) * 10000; return x - Math.floor(x); };
                    numberDiv.style.position = 'absolute';
                    numberDiv.style.top = (20 + rngN(0) * 60) + '%';
                    numberDiv.style.left = (10 + rngN(1) * 80) + '%';
                    numberDiv.style.fontSize = (15 + rngN(2) * 25) + 'vh';
                    numberDiv.style.transform = `translate(-50%, -50%) rotate(${rngN(3) * 30 - 15}deg)`;

                    if (elapsed < step.duration - 1000) {
                        numberDiv.innerText = Math.floor(Math.random() * 1000);
                    } else {
                        numberDiv.innerText = step.value || '42';
                    }
                    break;
                case 'breathing':
                    body.classList.add('breathing-bg');
                    body.style.setProperty('--breathing-color', step.value || '#333');
                    body.style.animationDuration = (step.speed || 4000) + 'ms';
                    break;
                case 'glitch':
                    body.classList.add('glitch-bg');
                    body.style.animationDuration = (step.speed || 300) + 'ms';
                    if (step.value) {
                        const gText = document.getElementById('glitch-text-overlay');
                        if (gText) {
                            gText.innerText = step.value;
                            gText.style.display = 'block';
                        }
                    }
                    break;
                case 'ripple':
                    const rippleCenter = document.getElementById('ripple-center');
                    rippleCenter.style.display = 'block';
                    rippleCenter.classList.add('active');
                    if (step.speed) rippleCenter.style.animationDuration = step.speed + 'ms';
                    break;
                case 'zoom':
                    body.classList.add('zoom-bg');
                    if (step.value) document.documentElement.style.setProperty('--zoom-intensity', step.value);
                    break;
                case 'shake':
                    body.classList.add('shake-bg');
                    if (step.value) document.documentElement.style.setProperty('--shake-intensity', step.value + 'px');
                    break;
                case 'fade':
                    const fadeDiv = document.getElementById('fade-overlay');
                    fadeDiv.style.display = 'block';
                    fadeDiv.style.backgroundColor = step.value || '#000';
                    fadeDiv.classList.add('active');
                    fadeDiv.style.opacity = Math.min(elapsed / (step.duration / 2), 1);
                    break;
                case 'cardFlip':
                    const cardFlipContainer = document.getElementById('card-flip-container');
                    cardFlipContainer.style.display = 'block';
                    const cardFlip = document.getElementById('card-flip');
                    cardFlip.innerHTML = `<img src="${step.value || 'cards/AC.jpg'}" style="width:100%;height:100%;object-fit:contain;">`;
                    cardFlip.style.animationDuration = (step.speed || 2000) + 'ms';
                    cardFlip.style.animationIterationCount = step.loop ? 'infinite' : '1';
                    break;
                case 'slot':
                    const slotDiv = document.getElementById('slot-container');
                    slotDiv.style.display = 'block';
                    if (elapsed < step.duration - 1000) {
                        const symbols = step.symbols || ['üçí', 'üçã', '‚≠ê'];
                        slotDiv.innerText = symbols[Math.floor(Math.random() * symbols.length)].repeat(3);
                    } else {
                        const final = step.value || '‚≠ê‚≠ê‚≠ê';
                        slotDiv.innerText = final;
                    }
                    break;
                case 'pinpoint':
                    const pinpoint = document.getElementById('pinpoint-target');
                    pinpoint.style.display = 'block';
                    pinpoint.style.left = (step.x || 50) + '%';
                    pinpoint.style.top = (step.y || 50) + '%';
                    if (step.color) {
                        pinpoint.style.borderColor = step.color;
                        pinpoint.style.boxShadow = `0 0 15px ${step.color}, inset 0 0 15px ${step.color}`;
                    }
                    break;
                case 'unlock':
                    const unlockIcon = document.getElementById('unlock-icon');
                    unlockIcon.style.display = 'block';
                    if (elapsed > step.duration / 2) {
                        unlockIcon.innerText = step.value || 'üîì';
                    } else {
                        unlockIcon.innerText = 'üîí';
                    }
                    break;
                case 'mirror':
                    body.classList.add(step.value === 'v' ? 'mirror-v' : 'mirror-h');
                    break;
                case 'wave':
                    const wave = document.getElementById('wave-overlay');
                    wave.style.display = 'block';
                    if (step.speed) wave.style.animationDuration = step.speed + 'ms';
                    break;
                case 'sparkle':
                    const density = step.value || 50; // Higher value = less frequent
                    if (elapsed % (20000 / density) < 20) {
                        const sparkle = document.createElement('div');
                        sparkle.className = 'sparkle-particle';
                        sparkle.style.left = Math.random() * 100 + '%';
                        sparkle.style.top = '0px';
                        if (step.color) sparkle.style.background = step.color;
                        document.getElementById('engine-screen').appendChild(sparkle);
                        setTimeout(() => sparkle.remove(), 2000);
                    }
                    break;
                case 'fire':
                    const fire = document.getElementById('fire-container');
                    fire.style.display = 'block';
                    if (step.value) fire.style.opacity = step.value / 100;
                    if (step.color) {
                        // Very basic tinting for fire - ideally would need more complex CSS filter
                        fire.style.filter = `drop-shadow(0 0 10px ${step.color})`;
                    }
                    break;
                case 'beat':
                    const bpm = step.speed || 120;
                    const beatInterval = 60000 / bpm;
                    if (elapsed % beatInterval < 300) {
                        body.classList.add('beat-flash');
                        if (step.color) document.documentElement.style.setProperty('--beat-color', step.color);
                        setTimeout(() => body.classList.remove('beat-flash'), 300);
                    }
                    break;
                case 'silence':
                    const allAudio = document.querySelectorAll('audio');
                    allAudio.forEach(a => a.pause());
                    break;
                case 'staticNoise':
                    const staticOv = document.getElementById('static-overlay');
                    staticOv.style.display = 'block';
                    if (step.value) staticOv.style.opacity = step.value / 100;
                    if (step.color) staticOv.style.backgroundColor = step.color; // Tinting
                    break;
                case 'eye':
                    const eye = document.getElementById('eye-container');
                    eye.style.display = 'block';
                    if (step.speed) eye.style.animationDuration = step.speed + 'ms';
                    break;
                case 'puzzle':
                    const puzzleContainer = document.getElementById('puzzle-container');
                    puzzleContainer.style.display = 'block';
                    if (elapsed === 0) {
                        const gridSize = 2; // Fixed for now, could be parameterized
                        for (let i = 0; i < 4; i++) {
                            const piece = document.createElement('div');
                            piece.className = 'puzzle-piece';
                            piece.style.left = (i % 2) * 50 + '%';
                            piece.style.top = Math.floor(i / 2) * 50 + '%';
                            piece.style.animationDuration = (step.speed || 1000) + 'ms';
                            puzzleContainer.appendChild(piece);
                        }
                    }
                    break;
                case 'mask':
                    const maskDiv = document.getElementById('mask-overlay');
                    maskDiv.style.display = 'block';
                    maskDiv.innerText = step.value || 'üé≠'; // Using value for maskType
                    break;
                case 'crystal':
                    const crystal = document.getElementById('crystal-ball');
                    crystal.style.display = 'block';
                    if (step.speed) crystal.style.animationDuration = step.speed + 'ms';
                    break;
                case 'snapshot':
                    const snapFlash = document.getElementById('snapshot-flash');
                    snapFlash.style.display = 'block';
                    snapFlash.classList.add('active');
                    setTimeout(() => {
                        snapFlash.classList.remove('active');
                        snapFlash.style.display = 'none';
                    }, step.speed || 500);
                    break;
                case 'starfield':
                    const starDensity = step.value || 50;
                    if (elapsed % (5000 / starDensity) < 20) {
                        const star = document.createElement('div');
                        star.className = 'star';
                        star.style.left = Math.random() * 100 + '%';
                        star.style.top = Math.random() * 100 + '%';
                        if (step.color) star.style.background = step.color;
                        document.getElementById('engine-screen').appendChild(star);
                        setTimeout(() => star.remove(), 3000);
                    }
                    break;
                case 'countdown':
                    const countdownDiv = document.getElementById('countdown-display');
                    countdownDiv.style.display = 'block';
                    if (step.color) countdownDiv.style.color = step.color;
                    const startFrom = step.value || 3;
                    const countInterval = step.duration / (startFrom + 1);
                    const current = startFrom - Math.floor(elapsed / countInterval);
                    countdownDiv.innerText = current > 0 ? current : 'GO';
                    break;
                case 'arrow':
                    const arrow = document.getElementById('arrow');
                    arrow.style.display = 'block';
                    if (step.value === 'bounce') {
                        arrow.style.animation = 'bounceArrow 1s infinite';
                    } else {
                        arrow.style.animation = 'none';
                    }
                    break;
                case 'pause':
                    // Pause: just wait, display nothing special
                    break;
                case 'revealImage':
                    const revealImgDiv = document.getElementById('reveal-image-display') || (() => {
                        const d = document.createElement('div');
                        d.id = 'reveal-image-display';
                        d.style.cssText = 'position:absolute;width:100%;height:100%;display:flex;align-items:center;justify-content:center;';
                        document.getElementById('engine-screen').appendChild(d);
                        return d;
                    })();
                    revealImgDiv.style.display = 'flex';
                    const images = step.images || [];
                    const finalImg = step.value || images[images.length - 1] || '';
                    if (elapsed < step.duration * 0.8 && images.length > 1) {
                        const randomImg = images[Math.floor(Math.random() * images.length)];
                        revealImgDiv.innerHTML = `<img src="${randomImg}" style="max-width:90%;max-height:90%;object-fit:contain;border-radius:12px;">`;
                    } else {
                        revealImgDiv.innerHTML = `<img src="${finalImg}" style="max-width:90%;max-height:90%;object-fit:contain;border-radius:12px;box-shadow:0 0 40px rgba(255,255,255,0.5);">`;
                    }
                    break;
                case 'stop':
                    body.className = '';
                    emojiDiv.innerText = '';
                    mediaImg.style.display = 'none';
                    videoVid.style.display = 'none';
                    document.getElementById('arrow').style.display = 'none';
                    return; // Stop halts the sequence
            }
        }

        function finishRoutine() {
            log("Routine termin√©e! Redirection imm√©diate...");
            document.querySelectorAll('audio').forEach(a => a.pause()); // Stop audio
            document.getElementById('engine-screen').classList.remove('active');
            // document.getElementById('final-screen').classList.add('active'); // Skipped per user request
            if (state.redirectionUrl) {
                window.location.href = state.redirectionUrl;
            } else {
                document.getElementById('final-screen').classList.add('active'); // Fallback only if no URL
            }
        }
        // ==========================================
        // ADMIN LOGIC MERGED
        // ==========================================

        let isAdmin = false;
        let lastRenderedSteps = '';

        // Admin Authentication / Panel Toggle
        // Long Press Logic is handled below or via existing listeners
        // Here we just need the open/close functions

        // Socket Listeners for Admin
        socket.on('admin-granted', () => {
            isAdmin = true;
            log("Mode Admin ACTIVE !");
            openAdminPanel();
            // Request current state to populate UI
            socket.emit('request-state');
        });

        function openAdminPanel() {
            if (!isAdmin) {
                // Auto-request admin without password
                socket.emit('promote-to-admin');
                // We wait for 'admin-granted' event to actually open the panel and set isAdmin=true
                return;
            }
            document.getElementById('settings-panel').classList.add('open');
            renderSteps();
            updateUI();
        }

        function closePanel() {
            document.getElementById('settings-panel').classList.remove('open');
        }

        // Update UI from state
        function updateUI() {
            if (!state || !state.routines) return;

            // Populate Routine Select
            const rSelect = document.getElementById('routine-select');
            rSelect.innerHTML = state.routines.map((r, i) => `<option value="${i}" ${i === state.activeRoutineIndex ? 'selected' : ''}>${r.name}</option>`).join('');

            // Populate Inputs
            document.getElementById('delay-input').value = state.synchroDelay / 1000 || 2;
            document.getElementById('zoom-val').innerText = state.logoZoom || 100;
            document.getElementById('zoom-range').value = state.logoZoom || 100;
            document.querySelector(`input[name="startImgSrc"][value="${state.startImageSource || 'logo'}"]`).checked = true;

            if (state.startImageSource === 'custom') {
                document.getElementById('custom-start-img-container').style.display = 'block';
                document.getElementById('start-img-url-input').value = state.startImageUrl || '';
            } else {
                document.getElementById('custom-start-img-container').style.display = 'none';
            }

            document.getElementById('welcome-text-input').value = state.welcomeText || '';
            document.getElementById('sub-text-input').value = state.subText || '';
            document.getElementById('logo-url-input').value = state.logoUrl || '';
            document.getElementById('redir-url-input').value = state.redirectionUrl || '';
            document.getElementById('tagline-input').value = state.tagline || '';

            document.getElementById('logs-toggle').checked = !!state.showLogs;
            document.getElementById('toggle-debug').checked = !!state.debug;
            document.getElementById('bg-color-input').value = state.bgColor || '#000000';
            document.getElementById('bg-anim-select').value = state.bgAnim || 'none';
            document.getElementById('start-anim-select').value = state.startAnim || 'fade';

            document.getElementById('connection-count').innerText = `üë§ ?`; // We don't have count in state usually, handled by socket event 'spectator-count'
        }

        // Render Steps List (Drag & Drop Logic included)
        function renderSteps() {
            if (!state.routines) return;
            const list = document.getElementById('steps-list');
            const currentScroll = list.scrollTop;
            const routine = state.routines[state.activeRoutineIndex];

            if (!routine) { list.innerHTML = '<p style="color:#aaa;font-size:12px;padding:10px;">Aucune routine active.</p>'; return; }

            // Icons mapping
            const icons = { emojis: 'üÉè', blackout: '‚¨õ', flash: '‚ö°', shuffle: 'üîÄ', reveal: 'üé¥', revealImage: 'üñºÔ∏è', video: 'üé¨', words: 'üî§', lottie: 'üéÜ', arrow: '‚¨á', heart: '‚ù§Ô∏è', countdown: 'üî¢', dice: 'üé≤', rippleFromLogo: '„Ä∞Ô∏è', audio: 'üîä', text: 'üìù', pulse: 'üíì', spiral: 'üåÄ', color: 'üé®', number: 'üî¢', breathing: 'ü´Å', glitch: '‚ö°', ripple: '„Ä∞Ô∏è', zoom: 'üîç', shake: 'üì£', fade: 'üå´Ô∏è', pause: '‚è∏', cardFlip: 'üé¥', slot: 'üé∞', pinpoint: 'üéØ', unlock: 'üîì', mirror: 'ü™û', wave: 'üåä', sparkle: '‚ú®', fire: 'üî•', beat: 'üéµ', silence: 'üîá', staticNoise: 'üìª', eye: 'üëÅÔ∏è', puzzle: 'üß©', mask: 'üé≠', crystal: 'üîÆ', snapshot: 'üì∏', starfield: 'üåü', stop: '‚èπ' };

            list.innerHTML = routine.steps.map((step, idx) => `
            <div class="step-item" draggable="true" data-idx="${idx}">
                <div class="step-handle">‚ò∞</div>
                <div class="step-info" onclick="editStep(${idx})">
                    <div class="step-name">${icons[step.type] || '‚ñ∂'} ${step.type.toUpperCase()}</div>
                    <div class="step-meta">${step.duration}ms ${step.value ? '| ' + step.value : ''} ${step.vibrate ? '| Vib' : ''}</div>
                </div>
                <div class="step-toggle ${step.active ? 'active' : ''}" onclick="event.stopPropagation(); toggleStep(${idx})"></div>
                <div class="step-delete" onclick="event.stopPropagation(); deleteStep(${idx})">üóëÔ∏è</div>
            </div>
        `).join('');

            // Re-attach Drag Listeners
            list.querySelectorAll('.step-item').forEach(item => {
                const handle = item.querySelector('.step-handle');
                let startY = 0, currentItem = null;

                // Touch Drag
                handle.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scroll
                    currentItem = item;
                    // startY = e.touches[0].clientY; // Not needed if we use simple append logic
                    item.classList.add('dragging');
                    item.style.zIndex = '100';
                }, { passive: false });

                handle.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!currentItem) return;
                    const y = e.touches[0].clientY;
                    const after = getDragAfter(list, y);
                    if (!after) list.appendChild(currentItem);
                    else list.insertBefore(currentItem, after);
                }, { passive: false });

                handle.addEventListener('touchend', () => {
                    if (!currentItem) return;
                    currentItem.classList.remove('dragging');
                    currentItem.style.zIndex = '';
                    currentItem = null;
                    saveReorder();
                });

                // Desktop Drag
                item.addEventListener('dragstart', () => {
                    item.classList.add('dragging');
                });
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    saveReorder();
                });
            });

            // Container Drag Over (Desktop)
            list.addEventListener('dragover', e => {
                e.preventDefault();
                const dragging = list.querySelector('.dragging');
                const after = getDragAfter(list, e.clientY);
                if (!after) list.appendChild(dragging); else list.insertBefore(dragging, after);
            });

            // Restore scroll
            requestAnimationFrame(() => { list.scrollTop = currentScroll; });
        }

        function getDragAfter(container, y) {
            const els = [...container.querySelectorAll('.step-item:not(.dragging)')];
            return els.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset, element: child };
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function saveReorder() {
            const list = document.getElementById('steps-list');
            const newOrder = [...list.querySelectorAll('.step-item')].map(el => parseInt(el.dataset.idx));
            const routine = state.routines[state.activeRoutineIndex];
            const oldSteps = routine.steps;
            const reordered = newOrder.map(i => oldSteps[i]);

            routine.steps = reordered;
            syncState(); // Emit update
        }

        // --- Actions ---

        function syncState() {
            socket.emit('update-state', state);
            // Also update local UI if needed, but socket 'state-update' listener usually handles it.
            // However, for admin inputs, we might want immediate feedback or wait for server.
            // Let's rely on server echo for robustness, but renderSteps might flicker if we wait. 
            // Admin.html logic called renderSteps immediately.
            renderSteps();
        }

        function addRoutine() {
            const name = prompt("Nom de la routine ?", "Nouveau Spectacle");
            if (!name) return;
            state.routines.push({ id: Date.now(), name, steps: [] });
            state.activeRoutineIndex = state.routines.length - 1;
            syncState();
            updateUI();
        }

        function switchRoutine(idx) {
            state.activeRoutineIndex = parseInt(idx);
            syncState();
            renderSteps();
        }

        function toggleStep(idx) {
            const step = state.routines[state.activeRoutineIndex].steps[idx];
            step.active = !step.active;
            syncState();
        }

        function deleteStep(idx) {
            if (!confirm("Supprimer cette √©tape ?")) return;
            state.routines[state.activeRoutineIndex].steps.splice(idx, 1);
            syncState();
        }

        // Add Step Form
        function showAddStepForm() {
            const area = document.getElementById('step-add-area');
            area.innerHTML = `
            <div class="step-add-form">
                <select id="new-step-type">
                    <option value="flash">‚ö° Flash</option>
                    <option value="text">üìù Text</option>
                    <option value="audio">üîä Audio</option>
                    <option value="video">üé¨ Video (URL)</option>
                    <option value="image">üñºÔ∏è Image (URL)</option>
                    <option value="reveal">üé¥ Reveal Card</option>
                    <option value="revealImage">üñºÔ∏è Reveal Image</option>
                    <option value="pause">‚è∏ Pause</option>
                    <option value="blackout">‚¨õ Blackout</option>
                    <option value="stop">‚èπ Stop</option>
                    <!-- Add others as needed -->
                </select>
                <input type="number" id="new-step-duration" placeholder="MS (ex: 2000)" value="2000">
                <input type="text" id="new-step-value" placeholder="Valeur (Texte, URL...)">
                <button onclick="confirmAddStep()">AJOUTER</button>
                <button onclick="document.getElementById('step-add-area').innerHTML=''" style="background:#555">ANNULER</button>
            </div>
        `;
        }

        function confirmAddStep() {
            const type = document.getElementById('new-step-type').value;
            const duration = parseInt(document.getElementById('new-step-duration').value) || 2000;
            const value = document.getElementById('new-step-value').value;

            const newStep = { type, duration, value, active: true, id: Date.now() };
            state.routines[state.activeRoutineIndex].steps.push(newStep);
            syncState();
            // Keep form open? Admin.html kept it but cleared value
            document.getElementById('new-step-value').value = '';
        }

        function editStep(idx) {
            const step = state.routines[state.activeRoutineIndex].steps[idx];
            const val = prompt("Nouvelle valeur (ou laisser vide) :", step.value || '');
            if (val !== null) {
                step.value = val;
                const dur = prompt("Nouvelle dur√©e (ms) :", step.duration);
                if (dur) step.duration = parseInt(dur);
                syncState();
            }
        }

        // Settings Handlers
        function toggleGuide() {
            const guide = document.getElementById('step-guide');
            guide.style.display = guide.style.display === 'block' ? 'none' : 'block';
        }

        function updateZoom(val) {
            document.getElementById('zoom-val').innerText = val;
            state.logoZoom = parseInt(val);
            // Note: transparency logic is inline in HTML event handlers
            syncState();
            // Live update local logo to see effect immediately?
            // updateLogoDisplay(); // Called by socket update, but we can call it here too
        }

        function setStartImgSource(src) {
            state.startImageSource = src;
            if (src === 'custom') {
                document.getElementById('custom-start-img-container').style.display = 'block';
            } else {
                document.getElementById('custom-start-img-container').style.display = 'none';
            }
            syncState();
        }

        function updateStartImage(url) {
            state.startImageUrl = url;
            syncState();
        }

        function updateTexts() {
            state.welcomeText = document.getElementById('welcome-text-input').value;
            state.subText = document.getElementById('sub-text-input').value;
            state.tagline = document.getElementById('tagline-input').value;
            state.redirectionUrl = document.getElementById('redir-url-input').value;
            state.logoUrl = document.getElementById('logo-url-input').value;
            syncState();
        }

        function toggleLogs(checked) {
            state.showLogs = checked;
            syncState();
        }

        function setBgColor(col) {
            state.bgColor = col;
            syncState();
        }

        function setBgAnim(anim) {
            state.bgAnim = anim;
            syncState();
        }

        function setStartAnim(anim) {
            state.startAnim = anim;
            syncState();
        }

        function previewLogo(url) {
            // Just update local input, calling sync in onchange
            updateTexts();
        }

        function autoColorFromLogo() {
            // Placeholder - logic was to invoke ColorThief or similar, but maybe just simple tint
            alert("Fonctionnalit√© Auto-Color √† impl√©menter (n√©cessite lib externe ou canvas analysis)");
        }

        // QR Generation
        function generateQR() {
            const canvas = document.getElementById('qr-canvas');
            const container = document.getElementById('qr-container');
            const url = window.location.href.split('?')[0]; // Current URL base

            container.innerHTML = '';
            const qr = new QRCode(container, {
                text: url,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });

            // Wait for generation then draw to canvas for download
            setTimeout(() => {
                const img = container.querySelector('img');
                if (img) {
                    canvas.width = 200;
                    canvas.height = 200;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                }
            }, 500);
        }

        function downloadQR() {
            const canvas = document.getElementById('qr-canvas');
            const link = document.createElement('a');
            link.download = 'crowdconnect-qr.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function saveAll() {
            // Just sync
            syncState();
            alert("Configuration sauvegard√©e et synchronis√©e !");
        }

        // File Upload Handlers (Simple fetch)
        async function handleFileUpload(input) {
            // Logic to upload logo
            const file = input.files[0];
            if (!file) return;
            const formData = new FormData();
            formData.append('logoFile', file);
            try {
                const res = await fetch('/upload-logo', { method: 'POST', body: formData });
                if (res.ok) {
                    const data = await res.json();
                    state.logoUrl = data.path; // server returns path
                    updateTexts(); // Sync
                    alert("Logo upload√© !");
                }
            } catch (e) { console.error(e); alert("Erreur upload"); }
        }

        async function handleStartImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const formData = new FormData();
            formData.append('startImage', file); // Check server endpoint expectation
            try {
                const res = await fetch('/upload-start-image', { method: 'POST', body: formData });
                if (res.ok) {
                    const data = await res.json();
                    state.startImageUrl = data.path;
                    syncState();
                    alert("Image upload√©e !");
                }
            } catch (e) { console.error(e); alert("Erreur upload"); }
        }

        // Admin Gesture (Long Press) - Re-implementing with flag check
        // If not admin, request admin. If admin, open panel.
        let adminTouchTimer = null;
        let adminStartX = 0, adminStartY = 0;

        document.addEventListener('touchstart', (e) => {
            // Ignore if valid interaction
            if (e.target.closest('button, input, select, .step-handle')) return;

            if (e.touches.length === 1) {
                // Restriction zone haut-gauche (150x150px)
                const x = e.touches[0].clientX;
                const y = e.touches[0].clientY;
                if (x > 150 || y > 150) return;

                adminStartX = x;
                adminStartY = y;
                adminTouchTimer = setTimeout(() => {
                    // Trigger
                    log("Long Press (Top-Left) Detected");
                    if (navigator.vibrate) navigator.vibrate(50);
                    openAdminPanel();
                }, 1500);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (adminTouchTimer) {
                const diffX = Math.abs(e.touches[0].clientX - adminStartX);
                const diffY = Math.abs(e.touches[0].clientY - adminStartY);
                if (diffX > 20 || diffY > 20) {
                    clearTimeout(adminTouchTimer);
                    adminTouchTimer = null;
                }
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (adminTouchTimer) clearTimeout(adminTouchTimer);
        });

    </script>
</body>

</html>